/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Tue Oct 11 2016 15:46:11 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (PluginConfig,
             pluginMetadata,
             PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of MiniProject2.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin MiniProject2.
     * @constructor
     */
    var MiniProject2 = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    MiniProject2.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    MiniProject2.prototype = Object.create(PluginBase.prototype);
    MiniProject2.prototype.constructor = MiniProject2;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    MiniProject2.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject,
            artifact;

        MiniProject2.prototype.loadNodeMap = function (node) {
            var self = this;
            return self.core.loadSubTree(node)
                .then(function (nodeArr) {
                    var nodes = {},
                        i;
                    for (i = 0; i < nodeArr.length; i += 1) {
                        nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
                    }

                    return nodes;
                });
        };
        self.metaNodeInfo = [];

        self.loadNodeMap(self.rootNode)
            .then(function (nodes) {
                self.logger.info(Object.keys(nodes));
                //self.printRandomly(nodes);
                self.buildMetaInfo(self.rootNode, nodes);
                self.result.setSuccess(true);
                var metaNodeInfoJson = JSON.stringify(self.metaNodeInfo, null, 4);
                artifact = self.blobClient.createArtifact('data');
                self.logger.info(metaNodeInfoJson);
                return artifact.addFile('metaNodeInfo.json', metaNodeInfoJson);
                //callback(null, self.result);
            })
            .then(function (fileHash) {
                self.result.addArtifact(fileHash);
                return artifact.save();
            })
            .then(function (artifactHash) {
                self.result.addArtifact(artifactHash);
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                // (3)
                self.logger.error(err.stack);
                // Result success is false at invocation.
                callback(err, self.result);
            });

        MiniProject2.prototype.buildMetaInfo = function (root, nodes, indent) {
            var self = this,
                childrenPaths,
                childNode,
                i,
                isMetaNode,
                metaNode,
                metaPath,
                myPath,
                name,
                isConnection = false,
                src,
                dst,
                baseNode,
                connectStr = '';
            indent = indent || '';
            childrenPaths = self.core.getChildrenPaths(root);

            // detecting if it is a meta node


            name = self.core.getAttribute(root, 'name');
            var path = self.core.getPath(root);


            metaNode = self.getMetaType(root);

            baseNode = self.core.getPointerPath(root, 'base');
            self.logger.info("baseNodePath: ", baseNode);
            if( baseNode !== null) {
                baseNode = self.core.getAttribute(nodes[baseNode], 'name');
            }
            else
                baseNode = "null";
            metaPath = self.core.getPath(metaNode);
            myPath = self.core.getPath(root);
            isMetaNode = (metaPath === myPath);
            //self.logger.info(name,metaPath,myPath, "isMeta", (metaPath === myPath));

            // checking if it is a connection node
            src = self.core.getPointerPath(root, 'src');
            dst = self.core.getPointerPath(root, 'dst');
            if (src && dst) {
                isConnection = true;
                src = nodes[src];
                dst = nodes[dst];
                src = self.core.getAttribute(src, "name");
                dst = self.core.getAttribute(dst, "name");
                connectStr = src + " --> " + dst;
            }
            //self.logger.info(indent, "isMeta", isMetaNode, "isConnection", isConnection, self.core.getAttribute(root, 'name'), 'has', childrenPaths.length, "children.", connectStr)

            if (isMetaNode) {
                if (isConnection)
                    self.metaNodeInfo.push({
                        name: name,
                        path: myPath,
                        nbrOfChildren: childrenPaths.length,
                        connection: connectStr
                    });
                else
                    self.metaNodeInfo.push({name: name, path: myPath, nbrOfChildren: childrenPaths.length, base: baseNode});
            }
            for (i = 0; i < childrenPaths.length; i++) {
                childNode = nodes[childrenPaths[i]];
                self.buildMetaInfo(childNode, nodes, indent + '  ');
            }
        }
    };

    return MiniProject2;
});