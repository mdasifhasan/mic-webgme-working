/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Tue Oct 11 2016 15:46:11 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of TutorialPlugin.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin TutorialPlugin.
     * @constructor
     */
    var TutorialPlugin = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    TutorialPlugin.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    TutorialPlugin.prototype = Object.create(PluginBase.prototype);
    TutorialPlugin.prototype.constructor = TutorialPlugin;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    TutorialPlugin.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject,
            artifact;

        TutorialPlugin.prototype.loadNodeMap = function (node) {
            var self = this;
            return self.core.loadSubTree(node)
                .then(function (nodeArr) {
                    var nodes = {},
                        i;
                    for (i = 0; i < nodeArr.length; i += 1) {
                        nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
                    }

                    return nodes;
                });
        };
        self.metaNodeInfo = [];

        self.loadNodeMap(self.rootNode)
            .then(function (nodes) {
                self.logger.info(Object.keys(nodes));
                //self.printRandomly(nodes);
                self.buildMetaInfo(self.rootNode, nodes);
                self.result.setSuccess(true);
                var metaNodeInfoJson = JSON.stringify(self.metaNodeInfo, null, 4);
                artifact = self.blobClient.createArtifact('data');
                self.logger.info(metaNodeInfoJson);
                return artifact.addFile('metaNodeInfo.json', metaNodeInfoJson);
                //callback(null, self.result);
            })
            .then(function (fileHash) {
                self.result.addArtifact(fileHash);
                return artifact.save();
            })
            .then(function (artifactHash) {
                self.result.addArtifact(artifactHash);
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                // (3)
                self.logger.error(err.stack);
                // Result success is false at invocation.
                callback(err, self.result);
            });

        TutorialPlugin.prototype.printRandomly = function (nodes) {
            var self = this,
                path,
                name,
                attr,
                node,
                metaNode;

            for (path in nodes) {
                node = nodes[path];
                name = self.core.getAttribute(node, 'name');
                //self.logger.info(name, 'has path', self.core.getPath(node));
                if(self.isMetaTypeOf(node, self.META.Transition)){
                    attr = self.core.getAttribute(node, 'guard');
                    self.logger.info(name, 'has attribute', attr);
                }
                else{
                    metaNode = self.getMetaType(node);
                    self.logger.info(name, " metaNode isNull: ", metaNode === null);
                    //if(metaNode !== null)
                        //self.logger.info(name, 'is of meta-type', self.core.getAttribute(metaNode, 'name'));
                }
            }
        };

        TutorialPlugin.prototype.buildMetaInfo = function (root, nodes, indent) {
            var self = this,
                childrenPaths,
                childNode,
                i,
                isMetaNode,
                metaNode,
                metaPath,
                myPath,
                name,
                isConnection = false,
                src,
                dst,
                connectStr = '';
            indent = indent || '';
            childrenPaths = self.core.getChildrenPaths(root);

            // detecting if it is a meta node
            name = self.core.getAttribute(root, 'name');
            metaNode = self.getMetaType(root);
            metaPath = self.core.getPath(metaNode);
            myPath = self.core.getPath(root);
            isMetaNode = (metaPath === myPath);
            //self.logger.info(name,metaPath,myPath, "isMeta", (metaPath === myPath));

            // checking if it is a connection node
            src = self.core.getPointerPath(root, 'src');
            dst = self.core.getPointerPath(root, 'dst');
            if (src && dst){
                isConnection = true;
                src = nodes[src];
                dst = nodes[dst];
                src = self.core.getAttribute(src, "name");
                dst = self.core.getAttribute(dst, "name");
                connectStr = src + " --> " + dst;
            }
            self.logger.info(indent, "isMeta", isMetaNode, "isConnection", isConnection, self.core.getAttribute(root, 'name'), 'has', childrenPaths.length, "children.", connectStr)

            if(isConnection)
                self.metaNodeInfo.push({name: name, path: myPath, numberOfChildren: childrenPaths.length, connection:connectStr});
            else
                self.metaNodeInfo.push({name: name, path: myPath, numberOfChildren: childrenPaths.length});
            for(i = 0; i < childrenPaths.length; i++){
                childNode = nodes[childrenPaths[i]];
                self.buildMetaInfo(childNode, nodes, indent + '  ');
            }
        }
    };

    return TutorialPlugin;
});
